<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Centipede Game with Phaser</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />
  </head>
  <style>
    body {
      background-image: url("./assets/tiles-page-background.png");
    }
  </style>
  <body>
    <script>
      let globalMushroomsData = [];
      class Scene1 extends Phaser.Scene {
        constructor() {
          super("bootGame");
        }
        preload() {
          this.load.image("background", "assets/background.jpg");
        }
        create() {
          console.log("v1.2");
          const background = this.add.tileSprite(
            400,
            300,
            800,
            600,
            "background"
          );
          background.setScrollFactor(0); // Fix the background position
          // Calculate the center of the game window
          const centerX = this.game.config.width / 2;
          const centerY = this.game.config.height / 2;
          this.add.text(centerX - 150, centerY - 100, "CENTIPEDE", {
            fontFamily: "VT323",
            fontSize: "80px",
            color: "#00ff00",
          });
          // Create the "Click to Start" text at the center
          const clickText = this.add.text(centerX, centerY, "Click to Start ", {
            fontFamily: "VT323",
            fontSize: "50px",
            color: "#00ff00",
          });

          // Set the origin of the text to the center
          clickText.setOrigin(0.5);

          // // Add a pulsing effect using tween
          this.tweens.add({
            targets: clickText,
            scaleX: 1.1,
            scaleY: 1.0,
            duration: 1000,
            ease: "Power2",
            yoyo: true,
            repeat: -1,
          });

          // Add an input event listener to the text
          clickText.setInteractive({ useHandCursor: true });
          clickText.on(
            "pointerdown",
            function () {
              // Start the "playGame" scene when the text is clicked
              // this.scene.start("playGame");
              this.scene.start("playGame", {
                score: (this.score = 0),
                lives: (this.lives = 0),
                wave: (this.wave = 1),
                bonus: (this.bonus = 0),
                textScore: (this.textScore = 0),
              });
            },
            this
          );
        }
      }
      class Scene2 extends Phaser.Scene {
        constructor() {
          super("playGame");
          // Declare class properties
          this.player;
          this.centipede;
          this.bullets;
          this.mushrooms;
          this.canShoot = true;
          this.lastShotTime = 0;
          this.spider;
          this.fireRate = 100;
          this.shootSound;
          this.destroySound;
          this.gameOverSound;
          this.mushroomTouchedByPlayerSound;
          this.score = 0; // Declare score as a property
          this.lives = 4;
          this.wave = 1;
          var textScore = 0;
          var textLives = 3;
          var textWave = 1;
          this.isPaused = false; // Add a property to track if the game is paused
          this.crabMushroomTouches = 0;
        }
        init(data) {
          this.score = data.score || 0; // Use passed score or default to 0
          this.textScore = data.textScore || 0;
          this.lives = data.lives || 4; // Use passed lives or some default
          this.wave = data.wave || 1; // Use passed wave or default to first wave
        }

        initHeartsDisplay() {
          const { width, height } = this.sys.game.config;
          const centerY = height / 2;
          const centerX = width / 2;
          this.hearts = []; // Reset the array
          const heartsSpacing = 50; // Space between hearts
          const heartPositionY = centerY - 290; // Y position for hearts
          const heartStartX = centerX - 380; // Adjust if necessary to match your UI layout

          // Start from the fixed position and add hearts to the right
          for (let i = 0; i < this.lives; i++) {
            const heart = this.add
              .image(heartStartX + i * heartsSpacing, heartPositionY, "heart")
              .setScale(0.5);
            this.hearts.push(heart);
          }
        }

        updateHeartsDisplay() {
          // Remove all current hearts
          this.hearts.forEach((heart) => heart.destroy());
          this.hearts = [];

          // Re-initialize the hearts display
          this.initHeartsDisplay();
        }

        preload() {
          this.load.image("startButton", "assets/startButton.png");
          this.load.image("player", "assets/player.png");
          this.load.image("centipede", "assets/centipede.png");
          this.load.image("bullet", "assets/bullet.png");
          this.load.image("mushroom", "assets/mushroom1.png");
          this.load.image("heart", "assets/heart.png");
          this.load.audio("shootSound", "assets/shoot.mp3");
          this.load.audio("destroySound", "assets/destroy.mp3");
          this.load.audio("gameOverSound", "assets/gameover.mp3"); // Adjust the path to your game over sound file
          this.load.audio(
            "mushroomTouchedByPlayer",
            "assets/mushroomTouchedByPlayer.mp3"
          );
          this.load.audio("crabEatsSound", "assets/crabEatsSound.mp3");
          this.load.image("background", "assets/background.jpg"); // Replace 'assets/background.jpg' with the path to your background image
          this.load.image("spider", "assets/spider1.png"); // Add spider image
          this.load.image("crab", "assets/crab.png"); // Ensure the path matches your asset's location
        }

        create() {
          this.startTime = this.time.now;
          // Calculate the center of the screen
          const { width, height } = this.sys.game.config;
          const centerX = width / 2;
          const centerY = height / 2;
          // Create a background tile sprite and set its scroll factor to create a repeating pattern
          const background = this.add.tileSprite(
            400,
            300,
            800,
            600,
            "background"
          );
          background.setScrollFactor(0); // Fix the background position

          this.initHeartsDisplay(); // Initialize hearts display

          this.player = this.physics.add
            .sprite(200, 300, "player")
            .setScale(0.5);
          this.shootSound = this.sound.add("shootSound");
          this.destroySound = this.sound.add("destroySound");
          this.gameOverSound = this.sound.add("gameOverSound"); // Initialize the game over sound
          this.crabEatsSound = this.sound.add("crabEatsSound");
          this.mushroomTouchedByPlayerSound = this.sound.add(
            "mushroomTouchedByPlayer"
          );
          this.spider =
            this.physics.add.sprite(/* spider coordinates and settings */);
          // Initialize the mushrooms as a static group
          this.mushrooms = this.physics.add.staticGroup();

          // lets make shrooms
          this.createMushroom = function (x, y) {
            const mushroom = this.mushrooms
              .create(x, y, "mushroom")
              .setScale(0.1);
            mushroom.body.immovable = true;
            mushroom.setData("hits", 0); // Use setData to store the hit count
            // Add the mushroom data to globalMushroomsData
            // globalMushroomsData.push({ x: x, y: y, hits: 0 });
            this.mushroomTouchedByPlayerSound.play();
            // additional logic for creating mushrooms
          };

          this.centipede = this.physics.add.group();
          this.createCentipede();

          // UI Text
          this.textScore = this.add.text(centerX - 390, centerY - 280, "0", {
            fontFamily: "VT323",
            fontSize: "50px",
            color: "#00ff00",
            // fill: '#00ff00'
          });
          this.textLives = this.lives;

          this.textLives = this.add.text(
            -100,
            -100,
            `Lives: ${this.textLives}`,
            {
              fontFamily: "VT323",
              fontSize: "24px",
              color: "#00ff00",
              // fill: '#00ff00'
            }
          );
          this.textWave = this.wave;
          this.textWave = this.add.text(
            centerX - 390,
            centerY - 240,
            `Wave: ${this.textWave}`,
            {
              fontFamily: "VT323",
              fontSize: "24px",
              color: "#00fff0",
              // fill: '#00ff00'
            }
          );

          // Create spider
          this.spider = this.physics.add
            .sprite(500, 700, "spider")
            .setScale(0.5);
          this.spider.setVelocityX(100);

          this.centipede = this.physics.add.group();
          this.createCentipede();

          this.bullets = this.physics.add.group({
            defaultKey: "bullet",
            maxSize: 1,
            active: false,
            visible: false,
          });
          this.physics.world.setBoundsCollision(true, true, true, false);
          // out off bounce
          this.bullets.children.iterate((bullet) => {
            bullet.on("outofbounds", () => {
              bullet.destroy();
              canShoot = true;
            });
          });

          this.bullets.children.iterate((bullet) => {
            bullet.on("destroy", () => {
              canShoot = true;
            });
          });

          this.mushrooms = this.physics.add.group();
          this.mushrooms.children.iterate((mushroom) => {
            this.mushroom.setScale(0.1);
          });

          // this.physics.add.collider(this.crab, this.player, () => {
          //   this.lives -= 1;
          //   this.textLives.setText("Lives: " + this.lives);
          //   this.player.setVelocity(0, 0);
          //   this.updateHeartsDisplay();
          //   console.log("touched the crab");
          //   console.log(this.lives);
          //   this.destroySound.play();
          // });

          ///was active
          // this.physics.add.collider(
          //   this.bullets,
          //   this.crab,
          //   this.bulletHitCrab,
          //   null,
          //   this
          // );
          // this.physics.add.collider(
          //   this.crab,
          //   this.mushrooms,
          //   this.crabHitsMushroom,
          //   null,
          //   this
          // );
          this.physics.add.collider(
            this.centipede,
            this.bullets,
            this.bulletHitCentipede.bind(this)
          );
          this.physics.add.collider(
            this.bullets,
            this.mushrooms,
            this.bulletHitMushroom.bind(this)
          );
          this.physics.add.collider(
            this.bullets,
            this.spider,
            this.bulletHitSpider.bind(this)
          );
          this.physics.add.overlap(
            this.centipede,
            this.mushrooms,
            this.centipedeHitMushroom.bind(this)
          );
          this.physics.add.overlap(
            this.player,
            this.centipede,
            this.playerHitCentipede.bind(this)
          );

          this.physics.add.collider(
            this.player,
            this.spider,
            this.playerHitSpider.bind(this)
          );

          //    this.physics.add.overlap(centipede, mushrooms, centipedeHitMushroom);
          this.input.on("pointermove", (pointer) => {
            const minY = (this.game.config.height * 2) / 3;
            const newX = Phaser.Math.Clamp(
              pointer.x,
              0,
              this.game.config.width
            );
            const newY = Phaser.Math.Clamp(
              pointer.y,
              minY,
              this.game.config.height
            );

            // Check for collisions with mushrooms
            let overlappingMushroom = false;

            // when the player touches the mushroom
            this.mushrooms.children.iterate((mushroom) => {
              const distance = Phaser.Math.Distance.Between(
                this.player.x,
                this.player.y,
                mushroom.x,
                mushroom.y
              );

              // Calculate the outer edge of the mushroom
              const mushroomOuterRadius = mushroom.width * 0.1 + 4;
              //  console.log(mushroom.width);
              // If the player is too close to the outer edge of the mushroom, prevent moving towards it
              if (distance < mushroomOuterRadius) {
                overlappingMushroom = true;
                // this.mushroomTouchedByPlayerSound.play();
                const angle = Phaser.Math.Angle.Between(
                  this.player.x,
                  this.player.y,
                  mushroom.x,
                  mushroom.y
                );
                const stopX =
                  this.player.x + (mushroomOuterRadius - 30) * Math.cos(angle);
                const stopY =
                  this.player.y + (mushroomOuterRadius - 30) * Math.sin(angle);

                this.player.x = Phaser.Math.Clamp(stopX, 0, game.config.width);
                this.player.y = Phaser.Math.Clamp(
                  stopY,
                  minY,
                  game.config.height
                );
              }
            });

            // Only update player position if not overlapping with any mushroom
            if (!overlappingMushroom) {
              this.player.x = newX;
              this.player.y = newY;
            }
          });
          // let isPointerDown = false;
          this.input.on("pointerdown", (pointer) => {
            this.isPointerDown = true;

            if (this.canShoot) {
              const bullet = this.bullets.get(this.player.x, this.player.y);

              if (bullet) {
                bullet.setActive(true);
                bullet.setVisible(true);
                bullet.body.velocity.y = -300;

                this.shootSound.play();
                this.canShoot = true;
              }
            }
          });
          this.createRandomMushrooms(30);
          this.createCrab();
        }

        restartGame() {
          this.gameOverSound.play();
          globalMushroomsData = [];
          // Reset game state
          // this.score = 11110;
          this.lives = 4;
          this.wave = 1;
          this.bonus = 0;
          this.score = 0;
          // this.textScore.setText("Score: " + this.score);
          // this.textLives.setText("Lives: " + this.lives);
          // this.textWave.setText("Wave: " + this.wave);
          // // Reset player position
          // this.player.setPosition(200, 300);

          // // Enable input events
          // this.input.enabled = true;

          // Restart the game loop
          // this.scene.start("bootGame");
          this.scene.start("bootGame", {
            score: (this.score = 0),
            lives: (this.lives = 0),
            wave: (this.wave = 1),
            bonus: (this.bonus = 0),
            textScore: (this.textScore = 0),
          });
        }

        fireBullet() {
          this.bullet = this.bullets.get(this.player.x, this.player.y);

          if (this.bullet) {
            this.bullet.setActive(true);
            this.bullet.setVisible(true);
            this.bullet.body.velocity.y = -500;

            this.shootSound.play();
          }
        }

        update() {
          if (this.lives === 0) {
            this.restartGame();
          }

          // Update spider movement and behavior
          if (this.spider) {
            this.moveSpider();
          }
          const pointer = this.input.activePointer;
          if (pointer.isDown) {
            this.fireBullet();
          }
          this.centipede.children.iterate((segment) => {
            if (segment.active) {
              segment.setVelocityX(250 * segment.getData("direction"));

              // Check if the centipede segment reaches the bottom
              if (segment.y >= game.config.height - 20) {
                segment.disableBody(true, true);
                this.score = 0;
                this.scoreText = "0";
                this.lives = 4;
                this.wave = 1;
                this.gameOverSound.play();
                this.scene.start("bootGame");
                // this.restartGame();
              }
            }
          });
          this.physics.world.wrap(this.bullets, 5);
          this.physics.world.wrap(this.bullets.children, 5);
          this.bullets.children.iterate((bullet) => {
            if (
              bullet.active &&
              (bullet.y < 0 || bullet.y > game.config.height)
            ) {
              bullet.destroy();
              this.canShoot = true;
            }
          });
          this.checkCentipedeCollision();
          // Check if all centipede segments are destroyed
          if (this.centipede.countActive() === 0) {
            this.nextLevel();
          }
        }

        nextLevel() {
          // Increase the difficulty or reset the game state for the next level
          // Adjust the speed of existing centipedes (increase the difficulty)
          // Transition to the ScoreScene

          const endTime = this.time.now;
          const durationInSeconds = (endTime - this.startTime) / 1000; // Phaser's time.now is in milliseconds
          //  let bonusScore = Math.max(0, (30 - durationInSeconds) * 10); // Example bonus calculation
          console.log(globalMushroomsData.length);
          let bonusScore = Math.max(
            0,
            Math.round((30 - durationInSeconds) * 200)
          );
          // Adjust bonusScore calculation as  10 points for each second under 30 seconds.

          // Ensure bonusScore is not negative
          bonusScore = Math.max(0, bonusScore);

          // this.wave = this.wave + 1;
          // this.textWave.setText("Wave: " + this.wave);
          // this.centipede.children.iterate((segment) => {
          //   if (segment.active) {
          //     const currentSpeed = segment.body.velocity.x;
          //     segment.setVelocityX(currentSpeed * 1.0); // Increase the speed by 10% (adjust as needed)
          //   }
          // });
          // this.createCentipede();
          // console.log("it me");
          // this.createRandomMushrooms(300);
          // this.createSpider();

          this.scene.start("ScoreScene", {
            score: this.score,
            lives: this.lives,
            wave: this.wave,
            bonusScore: bonusScore, // Pass the bonusScore to the ScoreScene
          });
        }

        createCentipede() {
          // Increase the speed each time the game restarts
          const speedMultiplier = 30; // You can adjust this multiplier as needed
          const segmentVelocityX = 250 * speedMultiplier;

          for (let i = 0; i < 8; i++) {
            const segment = this.centipede
              .create(32 + i * 40, 0, "centipede")
              .setActive(true);
            segment.setData("direction", 1);
            segment.setData("hasMovedDown", false);
            segment.setVelocityX(segmentVelocityX);
          }
        }

        bulletHitCentipede(centipedeSegment, bullet) {
          const pointsText = this.add
            .text(centipedeSegment.x + 10, centipedeSegment.y + 10, "80", {
              fontFamily: "VT323",
              fontSize: "20px",
              color: "#ffff00",
            })
            .setOrigin(0.5, 0.5);

          pointsText.setDepth(1);
          // Remove the points text
          this.time.delayedCall(400, () => {
            pointsText.destroy();
          });

          centipedeSegment.disableBody(true, true);
          bullet.destroy();
          this.destroySound.play();

          // Create a mushroom at the position of the centipede segment
          this.createMushroom(centipedeSegment.x, centipedeSegment.y);

          console.log(
            "before Create a mushroom at the position of the centipede segment",
            globalMushroomsData.length
          );
          globalMushroomsData.push({
            x: centipedeSegment.x,
            y: centipedeSegment.y,
            hits: 0,
          });
          console.log(
            "After Create a mushroom at the position of the centipede segment",
            globalMushroomsData.length
          );

          // Update the score when the player shoots a centipede segment
          this.score += 80;
          this.textScore.setText("" + this.score);
          this.canShoot = true; // Allow shooting again
        }

        bulletHitMushroom(bullet, mushroom) {
          let hits = mushroom.getData("hits") + 1; // Retrieve current hit count and increment
          mushroom.setData("hits", hits); // Update the hit count
          // Apply different tints based on the number of hits
          if (hits === 1) {
            mushroom.setTint(0xff9999); // Light red tint after the first hit
          } else if (hits === 2) {
            mushroom.setTint(0xff6666); // Darker red tint after the second hit
          }

          if (hits >= 3) {
            // Remove or update the mushroom in globalMushroomsData
            console.log("Before removal", globalMushroomsData.length);
            const index = globalMushroomsData.findIndex(
              (mData) => mData.x === mushroom.x && mData.y === mushroom.y
            );
            if (index > -1) {
              globalMushroomsData.splice(index, 1); // Or mark it as destroyed
            }

            const pointsText = this.add
              .text(mushroom.x, mushroom.y, "5", {
                fontFamily: "VT323",
                fontSize: "20px",
                color: "#ffff00",
              })
              .setOrigin(0.5, 0.5);
            // pointsText = "200";
            pointsText.setDepth(1);
            // Remove the points text
            this.time.delayedCall(400, () => {
              pointsText.destroy();
            });

            mushroom.destroy();
            console.log("After removal", globalMushroomsData.length);
            this.destroySound.play();
            // Update the score when the player shoots a mushroom
            this.score += 5;
            this.textScore.setText("" + this.score);
            this.textLives.setText("Lives: " + this.lives);
          } else {
            // Optional: Visual feedback that the mushroom was hit but not destroyed
          }

          bullet.destroy();

          this.canShoot = true; // Allow shooting again
        }

        bulletHitSpider(bullet, spider) {
          const pointsText = this.add
            .text(spider.x, spider.y, "200", {
              fontFamily: "VT323",
              fontSize: "20px",
              color: "#ffff00",
            })
            .setOrigin(0.5, 0.5);
          pointsText.setDepth(1);
          // Remove the points text
          this.time.delayedCall(400, () => {
            pointsText.destroy();
          });

          // Destroy the bullet and spider
          bullet.destroy();
          spider.destroy();

          // Update the score
          this.score += 200;
          this.bonus += 300;
          this.textScore.setText("" + this.score);
          this.textLives.setText("Lives: " + this.lives);
        }

        createRandomMushrooms(count) {
          // if (this.wave > 1) {
          //   count = count + this.wave * 2;
          // }

          // Use global data to place mushrooms if available
          //  console.log("data");
          //  console.log(globalMushroomsData.length);
          if (this.wave > 1 && globalMushroomsData.length > 0) {
            console.log("creating previous");
            console.log("whit the amount of :", globalMushroomsData.length);

            globalMushroomsData.forEach((mushroomData) => {
              this.createMushroom(mushroomData.x, mushroomData.y);
            });
          }
          // else {
          // Existing logic to randomly place mushrooms
          // For each new mushroom, add its data to globalMushroomsData

          const mushroomWidth = 30; // Adjust this based on your mushroom image size
          const spacing = mushroomWidth * 1;
          let currentIndex = 0;
          let delayBetween = 100;
          const createNextMushroom = () => {
            if (currentIndex < count) {
              const x = Phaser.Math.Between(
                spacing,
                game.config.width - spacing
              );
              const y = Phaser.Math.Between(
                spacing,
                game.config.height - spacing
              );

              this.createMushroom(x, y);

              currentIndex++;

              // Recursive call with a delay
              setTimeout(createNextMushroom, delayBetween);
            }
          };
          // Start the sequence
          createNextMushroom();
        }

        centipedeHitMushroom(centipedeSegment, mushroom) {
          // Change the movement direction to avoid being pushed out of bounds
          if (
            centipedeSegment.x < game.config.width - 20 &&
            centipedeSegment.x > 20
          ) {
            centipedeSegment.setData(
              "direction",
              -centipedeSegment.getData("direction")
            );
          } else {
            // If at the screen edge, move down and continue in the same direction
            centipedeSegment.y += 15; // Move down by 15 pixels
            centipedeSegment.setData(
              "direction",
              -centipedeSegment.getData("direction")
            );
          }

          // Move down and reverse the movement direction
          centipedeSegment.y += 5; // Adjust the value based on your preference
          centipedeSegment.setData(
            "direction",
            -centipedeSegment.getData("direction")
          );
        }

        playerHitCentipede(player, centipedeSegment) {
          this.restartGame();
        }

        checkCentipedeCollision() {
          this.centipede.children.iterate((segment) => {
            if (segment.active) {
              if (
                (segment.x >= game.config.width - 20 || segment.x <= 20) &&
                !segment.getData("hasMovedDown")
              ) {
                segment.y += 15; // Move down by 15 pixels
                segment.setData("direction", -segment.getData("direction"));
                segment.setData("hasMovedDown", true);
              } else if (segment.x < game.config.width - 20 && segment.x > 20) {
                // Reset the flag when it's not touching the sides
                segment.setData("hasMovedDown", false);
              }
            }
          });
        }

        playerHitSpider(player, spider) {
          // Handle spider-player collision logic
          // For example, decrease player health or trigger game over
          this.score -= 100;
          this.lives -= 1;
          this.textLives.setText("Lives: " + this.lives);
          this.mushroomTouchedByPlayerSound.play();
          spider.y = 0;
          spider.x = Phaser.Math.Between(50, 750);
          this.destroySound.play();
          this.updateHeartsDisplay();
        }

        createCrab() {
          // create a crab
          this.crab = this.physics.add.sprite(
            -100,
            (this.game.config.height * 2) / 3,
            "crab"
          );
          this.crab.setScale(0.2); // Adjust scale according to your needs

          // Randomly delay the start of crab movement after 4 seconds (4000ms)
          const minDelay = 4000; // Minimum delay of 4 seconds
          const randomAdditionalDelay = Phaser.Math.Between(0, 2000); // Add up to an additional 2 seconds

          this.physics.add.collider(
            this.bullets,
            this.crab,
            this.bulletHitCrab,
            null,
            this
          );
          this.physics.add.collider(
            this.crab,
            this.mushrooms,
            this.crabHitsMushroom,
            null,
            this
          );

          this.physics.add.collider(this.crab, this.player, () => {
            this.lives -= 1;
            this.textLives.setText("Lives: " + this.lives);
            this.player.setVelocity(0, 0);
            this.updateHeartsDisplay();
            console.log("touched the crab");
            console.log(this.lives);
            this.destroySound.play();
          });

          // Start moving the crab randomly after 4 to 6 seconds
          this.time.delayedCall(minDelay + randomAdditionalDelay, () => {
            if (!this.crab || !this.crab.body) {
              console.log("Crab does not exist or has been destroyed.");
              return; // Exit the function if crab doesn't exist
            }
            // this.moveCrab();
            console.log("left 2 right");
            //   // Set initial direction and speed
            let speed = 200;
            let direction = 1; // 1 for down, -1 for up
            if (this.crab) {
              this.crab.body.velocity.x = speed;
              this.crab.body.velocity.y = speed * direction;
              direction *= -1; // Change direction
              // Change direction every 500ms
              this.time.addEvent({
                delay: 1100,
                callback: () => {
                  if (!this.crab || !this.crab.body) return;
                  if (this.crab.x > this.game.config.width + 40) {
                    // If crab moves outside the play area, reset its position
                    this.crab.setPosition(
                      -100,
                      (this.game.config.height * 2) / 3
                    );
                    this.crab.body.velocity.x = speed;
                  } else {
                    // Change vertical direction
                    this.crab.body.velocity.y = speed * direction;
                    direction *= -1; // Change direction
                  }
                },
                loop: true,
              });
            } else {
            }
            // Set the crab's boundary limit based on the game's height
            const bottomBoundary =
              this.game.config.height - this.crab.displayHeight / 2; // Adjust if your crab has an offset

            // // Change direction every 3 seconds
            this.time.addEvent({
              delay: 4000, // 3000 milliseconds = 3 seconds
              callback: () => {
                if (!this.crab || !this.crab.body) return;
                this.crab.body.velocity.x = speed * direction;
                direction *= +1; // Change direction
                // Check if the crab is beyond the bottom play area and adjust
                if (this.crab.y > bottomBoundary) {
                  this.crab.y = bottomBoundary; // Reset crab's y position to within the play area
                }
              },
              loop: true,
            });
          });
          // moveCrabRight`, do similarly
          this.time.delayedCall(minDelay + Phaser.Math.Between(0, 2000), () => {
            if (!this.crab || !this.crab.body) {
              console.log("Crab does not exist or has been destroyed.");
              return; // Exit the function if crab doesn't exist
            }
            //  this.moveCrabRight();
            console.log("left 2 right");
            // Set initial direction and speed
            let speed = 200;
            let direction = 1; // 1 for down, -1 for up
            if (this.crab) {
              // Spawn the crab on the right side and move it to the left
              this.crab.setPosition(
                this.game.config.width + 100,
                (this.game.config.height * 2) / 3
              );
              this.crab.body.velocity.x = -speed; // Move left
              this.crab.body.velocity.y = speed * direction;
              direction *= -1; // Change direction

              // Adjust the timer to change vertical direction and check position
              this.time.addEvent({
                delay: 1000,
                callback: () => {
                  if (!this.crab || !this.crab.body) return;
                  // Check if the crab has moved outside the play area on the left
                  if (this.crab.x < -40) {
                    // Reset its position to the right side of the play area
                    this.crab.setPosition(
                      this.game.config.width + 100,
                      (this.game.config.height * 2) / 3
                    );
                    this.crab.body.velocity.x = -speed; // Continue moving left
                  } else {
                    // Change vertical direction
                    this.crab.body.velocity.y = speed * direction;
                    direction *= -1; // Toggle direction
                  }
                },
                loop: true,
              });
            }

            // Set the crab's boundary limit based on the game's height
            const bottomBoundary =
              this.game.config.height - this.crab.displayHeight / 2;

            // Change direction (up or down) every few seconds
            this.time.addEvent({
              delay: 4000,
              callback: () => {
                if (!this.crab || !this.crab.body) return;
                this.crab.body.velocity.x = -Math.abs(speed); // Ensure the crab continues moving left
                // Adjust if the crab is beyond the bottom play area
                if (this.crab.y > bottomBoundary) {
                  this.crab.y = bottomBoundary; // Reset crab's y position within the play area
                }
              },
              loop: true,
            });
          });
        }

        crabHitsMushroom(crab, mushroom) {
          // Check if this is the third mushroom touched
          //  console.log(this.crabMushroomTouches);
          this.crabMushroomTouches = ++this.crabMushroomTouches;
          if (this.crabMushroomTouches % 2 === 0) {
            this.sound.play("crabEatsSound");

            console.log(
              "Before removal crab mushroom",
              globalMushroomsData.length
            );
            const index = globalMushroomsData.findIndex(
              (mData) => mData.x === mushroom.x && mData.y === mushroom.y
            );
            if (index > -1) {
              globalMushroomsData.splice(index, 1); // Or mark it as destroyed
            }
            // Destroy the mushroom
            mushroom.destroy();
            console.log(
              "After removal crab mushroom",
              globalMushroomsData.length
            );
          }
        }

        moveSpider() {
          // Simple movement for the spider
          this.spider.y += 2;
          // Ensure spider and spider.body are defined
          if (this.spider && this.spider.body) {
            // If the spider reaches the screen edge, reverse its direction
            if (this.spider.x < 50 || this.spider.x > 750) {
              this.spider.setVelocityX(-this.spider.body.velocity.x);
            }
          }

          // If the spider reaches the bottom, reset its position
          if (this.spider.y > 600) {
            this.spider.y = 0;
            this.spider.x = Phaser.Math.Between(50, 750);
          }

          // // If the spider reaches the screen edge, reverse its direction
          // if (this.spider.x < 50 || this.spider.x > 750) {
          //   this.spider.setVelocityX(-this.spider.body.velocity.x);
          // }

          if (this.spider && this.spider.body) {
            // If the spider reaches the screen edge, reverse its direction
            if (this.spider.x < 50 || this.spider.x > 750) {
              // Check if the spider has a velocity before accessing it
              if (this.spider.body.velocity) {
                this.spider.setVelocityX(-this.spider.body.velocity.x);
              }
            }
          }
        }

        bulletHitCrab(bullet, crab) {
          const pointsText = this.add
            .text(crab.x, crab.y, "300", {
              fontFamily: "VT323",
              fontSize: "20px",
              color: "#ffff00",
            })
            .setOrigin(0.5, 0.5);
          pointsText.setDepth(1);
          // Remove the points text
          this.time.delayedCall(400, () => {
            pointsText.destroy();
          });
          bullet.destroy(); // Destroy the bullet
          crab.destroy(); // Destroy the crab
          this.score += 300; // Add 200 points to the player's score
          this.bonus += 400;
          this.textScore.setText(`${this.score}`); // Update the score display
          this.sound.play("destroySound"); // Play the destroy sound
          // create a crab
          this.createCrab();
        }

        createSpider() {
          // Create spider
          this.spider = this.physics.add
            .sprite(500, 700, "spider")
            .setScale(0.5);
          this.spider.setVelocityX(100);
          this.physics.add.collider(
            this.bullets,
            this.spider,
            this.bulletHitSpider.bind(this)
          );
          this.physics.add.collider(
            this.player,
            this.spider,
            this.playerHitSpider.bind(this)
          );
        }
      }
      class ScoreScene extends Phaser.Scene {
        constructor() {
          super("ScoreScene");
        }

        init(data) {
          // Receive score, lives, and wave from the previous scene
          this.score = data.score;
          this.lives = data.lives;
          this.wave = data.wave;
          this.bonusScore = data.bonusScore || 0; // Default to 0 if not provided
        }

        preload() {
          this.load.audio("tickSound", "assets/tick.mp3");
          this.load.audio("totalSound", "assets/total.mp3");
          this.load.image("heart", "assets/heart.png");
        }

        create() {
          // Calculate the center of the screen
          const { width, height } = this.sys.game.config;
          const centerX = width / 2;
          const centerY = height / 2;
          this.add.tileSprite(0, 0, width, height, "background").setOrigin(0);

          const heartsSpacing = 40; // Adjust based on the size of your heart sprite
          const firstHeartPositionX = centerX - 380; // Starting X position for the first heart
          const heartPositionY = centerY - 290; // Y position for all hearts

          for (let i = 0; i < this.lives; i++) {
            this.add
              .image(
                firstHeartPositionX + i * heartsSpacing,
                heartPositionY,
                "heart"
              )
              .setScale(0.5); // Scale as needed
          }

          // Display bonus score
          // this.add
          //   .text(centerX, centerY + 40, `Bonus Score: ${this.bonusScore}`, {
          //     fontFamily: "VT323",
          //     fontSize: "40px",
          //     color: "#ffffff",
          //   })
          //   .setOrigin(0.5);

          // Initial bonus score display
          let displayBonusScore = 0;
          let displayScore = 0;
          var displayTotal = this.bonusScore + this.score;

          this.add
            .text(centerX, centerY - 250, `Wave ${this.wave}`, {
              fontFamily: "VT323",
              fontSize: "100px",
              color: "#ffffff",
            })
            .setOrigin(0.5);

          const scoreBonusText = this.add
            .text(centerX, centerY - 130, `Score ${displayBonusScore}`, {
              fontFamily: "VT323",
              fontSize: "100px",
              color: "#ffffff",
            })
            .setOrigin(0.5);
          // Initial score display

          const scoreText = this.add
            .text(centerX, centerY - 50, `Score: ${displayScore}`, {
              fontFamily: "VT323",
              fontSize: "100px",
              color: "#ffffff",
            })
            .setOrigin(0.5);

          this.add
            .text(centerX + 110, centerY - 250, ``, {
              fontFamily: "VT323",
              fontSize: "100px",
              color: "#ffffff",
            })
            .setOrigin(0.5);

          const tickSound = this.sound.add("tickSound");
          const totalSound = this.sound.add("totalSound");
          // Function to update the score display

          const updateScoreDisplay = () => {
            displayScore++;
            displayScore = displayScore + 50; // Increment the displayed score
            scoreText.setText(`Score: ${displayScore}`);
            tickSound.play(); // Play the tick sound
            // Update the text
            console.log(displayTotal);
            if (displayScore < this.displayTotal) {
              this.time.delayedCall(80, updateScoreDisplay);
              //   tickSound.play();
              // Continue updating until reaching the final score
            } else {
              displayScore = displayTotal; // Increment the displayed score
              scoreText.setText(`Score: ${displayScore}`);
              tickSound.play();
              totalSound.play();
              // Create the continue button
              const continueButton = this.add
                .text(centerX, centerY + 150, "Continue", {
                  fontFamily: "VT323",
                  fontSize: "50px",
                  color: "#00ff00",
                })
                .setOrigin(0.5)
                .setInteractive({ useHandCursor: true }); // show continue

              continueButton.on("pointerdown", () => {
                this.score = displayTotal;
                //  console.log(this.score);
                this.scene.start("playGame", {
                  score: displayTotal, // Assuming this.score holds the final score
                  lives: this.lives, // Assuming this.lives holds the current lives count
                  wave: this.wave + 1, // Assuming this.wave holds the current wave number
                });

                // this.scene.start("playGame", { newLevel: true }); // Optionally pass data to the play scene
              });
            }
          };

          const updateScoreBonusDisplay = () => {
            displayBonusScore++;
            displayBonusScore = displayBonusScore + 50; // Increment the displayed score
            scoreBonusText.setText(`Bonus: ${displayBonusScore}`);
            tickSound.play(); // Play the tick sound
            // Update the text
            if (displayBonusScore < this.bonusScore) {
              this.time.delayedCall(80, updateScoreBonusDisplay);
              //   tickSound.play();
              // Continue updating until reaching the final score
            } else {
              // Start updating the score display
              updateScoreDisplay();
            }
          };
          // Start updating the score display
          updateScoreBonusDisplay();

          // continueButton.on("pointerdown", () => {
          //   this.score = displayTotal;
          //   //  console.log(this.score);
          //   this.scene.start("playGame", {
          //     score: displayTotal, // Assuming this.score holds the final score
          //     lives: this.lives, // Assuming this.lives holds the current lives count
          //     wave: this.wave + 1, // Assuming this.wave holds the current wave number
          //   });

          //   // this.scene.start("playGame", { newLevel: true }); // Optionally pass data to the play scene
          // });
        }
      }

      const gameConfig = {
        type: Phaser.AUTO,
        width: 800,
        height: 600,
        physics: {
          default: "arcade",
          arcade: {
            gravity: { y: 0 },
            debug: false,
          },
        },
        scene: [Scene1, Scene2, ScoreScene],
      };

      let game = new Phaser.Game(gameConfig);
    </script>
  </body>
</html>
